import { Alias, Connect } from 'vite';
import { L as LogLevel, M as MockServerPluginOptions, S as ServerBuildOption, a as MockOptions, b as MockHttpItem, c as MockWebsocketItem } from './types-D50kW_6z.cjs';
import EventEmitter from 'node:events';
import { FSWatcher } from 'chokidar';
import { CorsOptions } from 'cors';
import { Server } from 'node:http';
import { Http2SecureServer } from 'node:http2';
import 'node:buffer';
import 'node:stream';
import 'cookies';
import 'formidable';
import 'ws';
import 'co-body';

interface Logger {
    debug: (msg: string, level?: boolean | LogLevel) => void;
    info: (msg: string, level?: boolean | LogLevel) => void;
    warn: (msg: string, level?: boolean | LogLevel) => void;
    error: (msg: string, level?: boolean | LogLevel) => void;
}
declare const logLevels: Record<LogLevel, number>;
declare function createLogger(prefix: string, defaultLevel?: LogLevel): Logger;

type ResolvedMockServerPluginOptions = Required<Omit<MockServerPluginOptions, 'build' | 'cors' | 'wsPrefix' | 'prefix'>> & {
    context: string;
    logger: Logger;
    alias: Alias[];
    define: Record<string, any>;
    proxies: string[];
    wsProxies: string[];
    build: false | ServerBuildOption;
    cors: false | CorsOptions;
};

/**
 * mock配置加载器
 */
declare class MockCompiler extends EventEmitter {
    options: ResolvedMockServerPluginOptions;
    moduleCache: Map<string, MockOptions | MockHttpItem | MockWebsocketItem>;
    moduleDeps: Map<string, Set<string>>;
    cwd: string;
    mockWatcher: FSWatcher;
    depsWatcher: FSWatcher;
    moduleType: 'cjs' | 'esm';
    private _mockData;
    constructor(options: ResolvedMockServerPluginOptions);
    get mockData(): Record<string, MockOptions>;
    run(): void;
    private watchMockEntry;
    /**
     * 监听 mock文件依赖的本地文件变动，
     * mock依赖文件更新，mock文件也一并更新
     */
    private watchDeps;
    close(): void;
    private updateMockList;
    private updateModuleDeps;
    private loadMock;
}

interface BaseMiddlewareOptions {
    formidableOptions: MockServerPluginOptions['formidableOptions'];
    cookiesOptions: MockServerPluginOptions['cookiesOptions'];
    bodyParserOptions: MockServerPluginOptions['bodyParserOptions'];
    proxies: string[];
    logger: Logger;
    priority: MockServerPluginOptions['priority'];
}
declare function baseMiddleware(compiler: MockCompiler, { formidableOptions, bodyParserOptions, proxies, cookiesOptions, logger, priority, }: BaseMiddlewareOptions): Connect.NextHandleFunction;

/**
 * 不复用 `viteConfig.server.proxy` 中 websocket proxy的原因是，
 * 很难通过一种令人满意的方式，检查 mock 文件中是否有 websocket 相关的 mock 配置，
 * 对比 `server.proxy` 中被使用的，并从 `viteConfig.server.proxy` 中删除。
 * 由于不确定 mock 文件的规模，解析所有mock文件后找出相对应的路径匹配规则再修改 `viteConfig`，
 * 这个链路的时间开销，已经影响了 vite 开发服务的启动时间，这有违 vite 和插件的预期。
 * 且如果 新增的 mock 文件中 又有其他的规则需要再次 修改 `viteConfig` 导致 vite 服务重启，
 * 这其实并不是一个合适的处理方案，很难符合用户的预期。
 * 比较合适的方案还是提供 `wsPrefix` 配置项给用户自定义，并由用户确保 `wsPrefix` 中的项不存在
 * 于 `server.proxy` 中，避免 vite 内的 http-proxy ws 与 插件的 ws 的冲突。
 */

/**
 * mock websocket
 */
declare function mockWebSocket(compiler: MockCompiler, server: Server | Http2SecureServer | null, { wsProxies: proxies, cookiesOptions, logger, }: ResolvedMockServerPluginOptions): void;

type MockRawData = MockOptions | MockHttpItem | MockWebsocketItem | Record<string, MockOptions | MockHttpItem | MockWebsocketItem>;
declare function transformRawData(raw: MockRawData, __filepath__: string): MockOptions | MockHttpItem | MockWebsocketItem;
declare function transformMockData(mockList: Map<string, MockHttpItem | MockWebsocketItem | MockOptions> | (MockHttpItem | MockWebsocketItem | MockOptions)[]): Record<string, MockOptions>;
declare function sortByValidator(mocks: MockOptions): (MockHttpItem | MockWebsocketItem)[];

export { type BaseMiddlewareOptions, type Logger, baseMiddleware, createLogger, logLevels, mockWebSocket, sortByValidator, transformMockData, transformRawData };
