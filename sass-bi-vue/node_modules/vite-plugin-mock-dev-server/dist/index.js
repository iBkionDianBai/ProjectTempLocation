import {
  createDefineMock,
  defineMock,
  defineMockData
} from "./chunk-VMBOC7DG.js";
import {
  baseMiddleware,
  createLogger,
  debug,
  doesProxyContextMatchUrl,
  ensureProxies,
  logLevels,
  lookupFile,
  mockWebSocket,
  normalizePath,
  recoverRequest,
  sortByValidator,
  transformMockData,
  transformRawData,
  urlParse
} from "./chunk-TTKDHWOT.js";

// src/plugin.ts
import { toArray as toArray4 } from "@pengzhanbo/utils";

// src/core/build.ts
import fs2 from "node:fs";
import fsp2 from "node:fs/promises";
import path2 from "node:path";
import process2 from "node:process";
import { toArray } from "@pengzhanbo/utils";
import fg from "fast-glob";
import isCore from "is-core-module";
import { createFilter } from "@rollup/pluginutils";
import c from "picocolors";

// src/core/compiler.ts
import fs, { promises as fsp } from "node:fs";
import path from "node:path";
import { pathToFileURL } from "node:url";
import process from "node:process";
import { build } from "esbuild";
import JSON5 from "json5";
var externalizeDeps = {
  name: "externalize-deps",
  setup(build2) {
    build2.onResolve({ filter: /.*/ }, ({ path: id }) => {
      if (id[0] !== "." && !path.isAbsolute(id))
        return { external: true };
    });
  }
};
var json5Loader = {
  name: "json5-loader",
  setup(build2) {
    build2.onLoad({ filter: /\.json5$/ }, async ({ path: path3 }) => {
      const content = await fsp.readFile(path3, "utf-8");
      return {
        contents: `export default ${JSON.stringify(JSON5.parse(content))}`,
        loader: "js"
      };
    });
  }
};
var jsonLoader = {
  name: "json-loader",
  setup(build2) {
    build2.onLoad({ filter: /\.json$/ }, async ({ path: path3 }) => {
      const content = await fsp.readFile(path3, "utf-8");
      return {
        contents: `export default ${content}`,
        loader: "js"
      };
    });
  }
};
var renamePlugin = {
  name: "rename-plugin",
  setup(build2) {
    build2.onResolve({ filter: /.*/ }, ({ path: id }) => {
      if (id === "vite-plugin-mock-dev-server") {
        return {
          path: "vite-plugin-mock-dev-server/helper",
          external: true
        };
      }
      return null;
    });
  }
};
function aliasPlugin(alias) {
  return {
    name: "alias-plugin",
    setup(build2) {
      build2.onResolve({ filter: /.*/ }, async ({ path: id }) => {
        const matchedEntry = alias.find(({ find: find2 }) => aliasMatches(find2, id));
        if (!matchedEntry)
          return null;
        const { find, replacement } = matchedEntry;
        const result = await build2.resolve(id.replace(find, replacement), {
          kind: "import-statement",
          resolveDir: replacement,
          namespace: "file"
        });
        return {
          path: result.path,
          external: false
        };
      });
    }
  };
}
function aliasMatches(pattern, importee) {
  if (pattern instanceof RegExp)
    return pattern.test(importee);
  if (importee.length < pattern.length)
    return false;
  if (importee === pattern)
    return true;
  return importee.startsWith(`${pattern}/`);
}
async function transformWithEsbuild(entryPoint, options) {
  const { isESM = true, define, alias, cwd = process.cwd() } = options;
  const filepath = path.resolve(cwd, entryPoint);
  const filename = path.basename(entryPoint);
  const dirname = path.dirname(filepath);
  try {
    const result = await build({
      entryPoints: [entryPoint],
      outfile: "out.js",
      write: false,
      target: ["node18"],
      platform: "node",
      bundle: true,
      metafile: true,
      format: isESM ? "esm" : "cjs",
      define: {
        ...define,
        __dirname: JSON.stringify(dirname),
        __filename: JSON.stringify(filename),
        ...isESM ? {} : { "import.meta.url": JSON.stringify(pathToFileURL(filepath)) }
      },
      plugins: [aliasPlugin(alias), renamePlugin, externalizeDeps, jsonLoader, json5Loader],
      absWorkingDir: cwd
    });
    return {
      code: result.outputFiles[0].text,
      deps: result.metafile?.inputs || {}
    };
  } catch (e) {
    console.error(e);
  }
  return { code: "", deps: {} };
}
async function loadFromCode({
  filepath,
  code,
  isESM,
  cwd
}) {
  filepath = path.resolve(cwd, filepath);
  const ext = isESM ? ".mjs" : ".cjs";
  const filepathTmp = `${filepath}.timestamp-${Date.now()}${ext}`;
  const file = pathToFileURL(filepathTmp).toString();
  await fsp.writeFile(filepathTmp, code, "utf8");
  try {
    const mod = await import(file);
    return mod.default || mod;
  } finally {
    try {
      fs.unlinkSync(filepathTmp);
    } catch {
    }
  }
}

// src/core/build.ts
async function generateMockServer(ctx, options) {
  const include = toArray(options.include);
  const exclude = toArray(options.exclude);
  const cwd = options.cwd || process2.cwd();
  let pkg = {};
  try {
    const pkgStr = lookupFile(options.context, ["package.json"]);
    if (pkgStr)
      pkg = JSON.parse(pkgStr);
  } catch {
  }
  const outputDir = options.build.dist;
  const content = await generateMockEntryCode(cwd, include, exclude);
  const mockEntry = path2.join(cwd, `mock-data-${Date.now()}.js`);
  await fsp2.writeFile(mockEntry, content, "utf-8");
  const { code, deps } = await transformWithEsbuild(mockEntry, options);
  const mockDeps = getMockDependencies(deps, options.alias);
  await fsp2.unlink(mockEntry);
  const outputList = [
    {
      filename: path2.join(outputDir, "mock-data.js"),
      source: code
    },
    {
      filename: path2.join(outputDir, "index.js"),
      source: generatorServerEntryCode(options)
    },
    {
      filename: path2.join(outputDir, "package.json"),
      source: generatePackageJson(pkg, mockDeps)
    }
  ];
  try {
    if (path2.isAbsolute(outputDir)) {
      for (const { filename } of outputList) {
        if (fs2.existsSync(filename))
          await fsp2.rm(filename);
      }
      options.logger.info(`${c.green("\u2713")} generate mock server in ${c.cyan(outputDir)}`);
      for (const { filename, source } of outputList) {
        fs2.mkdirSync(path2.dirname(filename), { recursive: true });
        await fsp2.writeFile(filename, source, "utf-8");
        const sourceSize = (source.length / 1024).toFixed(2);
        const name = path2.relative(outputDir, filename);
        const space = name.length < 30 ? " ".repeat(30 - name.length) : "";
        options.logger.info(`  ${c.green(name)}${space}${c.bold(c.dim(`${sourceSize} kB`))}`);
      }
    } else {
      for (const { filename, source } of outputList) {
        ctx.emitFile({
          type: "asset",
          fileName: filename,
          source
        });
      }
    }
  } catch (e) {
    console.error(e);
  }
}
function getMockDependencies(deps, alias) {
  const list = /* @__PURE__ */ new Set();
  const excludeDeps = ["vite-plugin-mock-dev-server", "connect", "cors"];
  const isAlias = (p) => alias.find(({ find }) => aliasMatches(find, p));
  Object.keys(deps).forEach((mPath) => {
    const imports = deps[mPath].imports.filter((_) => _.external && !_.path.startsWith("<define:") && !isAlias(_.path)).map((_) => _.path);
    imports.forEach((dep) => {
      const name = normalizePackageName(dep);
      if (!excludeDeps.includes(name) && !isCore(name))
        list.add(name);
    });
  });
  return Array.from(list);
}
function normalizePackageName(dep) {
  const [scope, name] = dep.split("/");
  if (scope[0] === "@") {
    return `${scope}/${name}`;
  }
  return scope;
}
function generatePackageJson(pkg, mockDeps) {
  const { dependencies = {}, devDependencies = {} } = pkg;
  const dependents = { ...dependencies, ...devDependencies };
  const mockPkg = {
    name: "mock-server",
    type: "module",
    scripts: {
      start: "node index.js"
    },
    dependencies: {
      connect: "^3.7.0",
      ["vite-plugin-mock-dev-server"]: `^${"1.7.0"}`,
      cors: "^2.8.5"
    },
    pnpm: { peerDependencyRules: { ignoreMissing: ["vite"] } }
  };
  mockDeps.forEach((dep) => {
    mockPkg.dependencies[dep] = dependents[dep] || "latest";
  });
  return JSON.stringify(mockPkg, null, 2);
}
function generatorServerEntryCode({
  proxies,
  wsProxies,
  cookiesOptions,
  bodyParserOptions,
  priority,
  build: build2
}) {
  const { serverPort, log } = build2;
  return `import { createServer } from 'node:http';
import connect from 'connect';
import corsMiddleware from 'cors';
import { baseMiddleware, createLogger, mockWebSocket } from 'vite-plugin-mock-dev-server/server';
import mockData from './mock-data.js';

const app = connect();
const server = createServer(app);
const logger = createLogger('mock-server', '${log}');
const proxies = ${JSON.stringify(proxies)};
const wsProxies = ${JSON.stringify(wsProxies)};
const cookiesOptions = ${JSON.stringify(cookiesOptions)};
const bodyParserOptions = ${JSON.stringify(bodyParserOptions)};
const priority = ${JSON.stringify(priority)};
const compiler = { mockData }

mockWebSocket(compiler, server, { wsProxies, cookiesOptions, logger });

app.use(corsMiddleware());
app.use(baseMiddleware(compiler, {
  formidableOptions: { multiples: true },
  proxies,
  priority,
  cookiesOptions,
  bodyParserOptions,
  logger,
}));

server.listen(${serverPort});

console.log('listen: http://localhost:${serverPort}');
`;
}
async function generateMockEntryCode(cwd, include, exclude) {
  const includePaths = await fg(include, { cwd });
  const includeFilter = createFilter(include, exclude, {
    resolve: false
  });
  const mockFiles = includePaths.filter(includeFilter);
  let importers = "";
  const exporters = [];
  mockFiles.forEach((filepath, index) => {
    const file = normalizePath(path2.join(cwd, filepath));
    importers += `import * as m${index} from '${file}';
`;
    exporters.push(`[m${index}, '${filepath}']`);
  });
  return `import { transformMockData, transformRawData } from 'vite-plugin-mock-dev-server/server';
${importers}
const exporters = [
  ${exporters.join(",\n  ")}
];
const mockList = exporters.map(([mod, filepath]) => {
  const raw = mod.default || mod;
  return transformRawData(raw, filepath);
});
export default transformMockData(mockList);`;
}

// src/core/mockMiddleware.ts
import cors from "cors";
import { pathToRegexp } from "path-to-regexp";

// src/core/mockCompiler.ts
import EventEmitter from "node:events";
import process3 from "node:process";
import { promiseParallel, toArray as toArray2 } from "@pengzhanbo/utils";
import chokidar from "chokidar";
import fastGlob from "fast-glob";
import { createFilter as createFilter2 } from "@rollup/pluginutils";
function createMockCompiler(options) {
  return new MockCompiler(options);
}
var MockCompiler = class extends EventEmitter {
  constructor(options) {
    super();
    this.options = options;
    this.cwd = options.cwd || process3.cwd();
    try {
      const pkg = lookupFile(this.cwd, ["package.json"]);
      this.moduleType = !!pkg && JSON.parse(pkg).type === "module" ? "esm" : "cjs";
    } catch {
    }
  }
  moduleCache = /* @__PURE__ */ new Map();
  moduleDeps = /* @__PURE__ */ new Map();
  cwd;
  mockWatcher;
  depsWatcher;
  moduleType = "cjs";
  _mockData = {};
  get mockData() {
    return this._mockData;
  }
  run() {
    const { include, exclude } = this.options;
    const includeFilter = createFilter2(include, exclude, { resolve: false });
    fastGlob(include, { cwd: this.cwd }).then(
      (files) => files.filter(includeFilter).map((file) => () => this.loadMock(file))
    ).then((loadList) => promiseParallel(loadList, 10)).then(() => this.updateMockList());
    this.watchMockEntry();
    this.watchDeps();
    let timer = null;
    this.on("mock:update", async (filepath) => {
      if (!includeFilter(filepath))
        return;
      await this.loadMock(filepath);
      if (timer)
        clearImmediate(timer);
      timer = setImmediate(() => {
        this.updateMockList();
        this.emit("mock:update-end", filepath);
        timer = null;
      });
    });
    this.on("mock:unlink", async (filepath) => {
      if (!includeFilter(filepath))
        return;
      this.moduleCache.delete(filepath);
      this.updateMockList();
      this.emit("mock:update-end", filepath);
    });
  }
  watchMockEntry() {
    const { include } = this.options;
    const [firstGlob, ...otherGlob] = toArray2(include);
    const watcher = this.mockWatcher = chokidar.watch(firstGlob, {
      ignoreInitial: true,
      cwd: this.cwd
    });
    if (otherGlob.length > 0)
      otherGlob.forEach((glob) => watcher.add(glob));
    watcher.on("add", async (filepath) => {
      filepath = normalizePath(filepath);
      this.emit("mock:update", filepath);
      debug("watcher:add", filepath);
    });
    watcher.on("change", async (filepath) => {
      filepath = normalizePath(filepath);
      this.emit("mock:update", filepath);
      debug("watcher:change", filepath);
    });
    watcher.on("unlink", async (filepath) => {
      filepath = normalizePath(filepath);
      this.emit("mock:unlink", filepath);
      debug("watcher:unlink", filepath);
    });
  }
  /**
   * 监听 mock文件依赖的本地文件变动，
   * mock依赖文件更新，mock文件也一并更新
   */
  watchDeps() {
    const oldDeps = [];
    this.depsWatcher = chokidar.watch([], {
      ignoreInitial: true,
      cwd: this.cwd
    });
    this.depsWatcher.on("change", (filepath) => {
      filepath = normalizePath(filepath);
      const mockFiles = this.moduleDeps.get(filepath);
      mockFiles?.forEach((file) => {
        this.emit("mock:update", file);
      });
    });
    this.depsWatcher.on("unlink", (filepath) => {
      filepath = normalizePath(filepath);
      this.moduleDeps.delete(filepath);
    });
    this.on("update:deps", () => {
      const deps = [];
      for (const [dep] of this.moduleDeps.entries())
        deps.push(dep);
      const exactDeps = deps.filter((dep) => !oldDeps.includes(dep));
      if (exactDeps.length > 0)
        this.depsWatcher.add(exactDeps);
    });
  }
  close() {
    this.mockWatcher?.close();
    this.depsWatcher?.close();
  }
  updateMockList() {
    this._mockData = transformMockData(this.moduleCache);
  }
  updateModuleDeps(filepath, deps) {
    Object.keys(deps).forEach((mPath) => {
      const imports = deps[mPath].imports.map((_) => _.path);
      imports.forEach((dep) => {
        if (!this.moduleDeps.has(dep))
          this.moduleDeps.set(dep, /* @__PURE__ */ new Set());
        const cur = this.moduleDeps.get(dep);
        cur.add(filepath);
      });
    });
    this.emit("update:deps");
  }
  async loadMock(filepath) {
    if (!filepath)
      return;
    let isESM = false;
    if (/\.m[jt]s$/.test(filepath))
      isESM = true;
    else if (/\.c[jt]s$/.test(filepath))
      isESM = false;
    else
      isESM = this.moduleType === "esm";
    const { define, alias } = this.options;
    const { code, deps } = await transformWithEsbuild(
      filepath,
      { isESM, define, alias, cwd: this.cwd }
    );
    try {
      const raw = await loadFromCode({ filepath, code, isESM, cwd: this.cwd }) || {};
      this.moduleCache.set(filepath, transformRawData(raw, filepath));
      this.updateModuleDeps(filepath, deps);
    } catch (e) {
      console.error(e);
    }
  }
};

// src/core/mockMiddleware.ts
function mockServerMiddleware(options, server, ws) {
  const compiler = createMockCompiler(options);
  compiler.run();
  compiler.on("mock:update-end", () => {
    if (options.reload)
      ws?.send({ type: "full-reload" });
  });
  server?.on("close", () => compiler.close());
  mockWebSocket(compiler, server, options);
  const middlewares = [];
  middlewares.push(
    /**
     * 在 vite 的开发服务中，由于插件 的 enforce 为 `pre`，
     * mock 中间件的执行顺序 早于 vite 内部的 cors 中间件执行,
     * 这导致了 vite 默认开启的 cors 对 mock 请求不生效。
     * 在一些比如 微前端项目、或者联合项目中，会由于端口不一致而导致跨域问题。
     * 所以在这里，使用 cors 中间件 来解决这个问题。
     *
     * 同时为了使 插件内的 cors 和 vite 的 cors 不产生冲突，并拥有一致的默认行为，
     * 也会使用 viteConfig.server.cors 配置，并支持 用户可以对 mock 中的 cors 中间件进行配置。
     * 而用户的配置也仅对 mock 的接口生效。
     */
    corsMiddleware(compiler, options),
    baseMiddleware(compiler, options)
  );
  return middlewares.filter(Boolean);
}
function corsMiddleware(compiler, { proxies, cors: corsOptions }) {
  return !corsOptions ? void 0 : function(req, res, next) {
    const { pathname } = urlParse(req.url);
    if (!pathname || proxies.length === 0 || !proxies.some((context) => doesProxyContextMatchUrl(context, req.url))) {
      return next();
    }
    const mockData = compiler.mockData;
    const mockUrl = Object.keys(mockData).find(
      (key) => pathToRegexp(key).test(pathname)
    );
    if (!mockUrl)
      return next();
    cors(corsOptions)(req, res, next);
  };
}

// src/core/resolvePluginOptions.ts
import process5 from "node:process";
import { isArray, isBoolean, toArray as toArray3, uniq } from "@pengzhanbo/utils";
import color from "picocolors";

// src/core/define.ts
import process4 from "node:process";
function viteDefine(config) {
  const processNodeEnv = {};
  const nodeEnv = process4.env.NODE_ENV || config.mode;
  Object.assign(processNodeEnv, {
    "process.env.NODE_ENV": JSON.stringify(nodeEnv),
    "global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
    "globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
  });
  const userDefine = {};
  const userDefineEnv = {};
  for (const key in config.define) {
    const val = config.define[key];
    const isMetaEnv = key.startsWith("import.meta.env.");
    if (typeof val === "string") {
      if (canJsonParse(val)) {
        userDefine[key] = val;
        if (isMetaEnv)
          userDefineEnv[key.slice(16)] = val;
      }
    } else {
      userDefine[key] = handleDefineValue(val);
      if (isMetaEnv)
        userDefineEnv[key.slice(16)] = val;
    }
  }
  const importMetaKeys = {};
  const importMetaEnvKeys = {};
  const importMetaFallbackKeys = {};
  importMetaKeys["import.meta.hot"] = `undefined`;
  for (const key in config.env) {
    const val = JSON.stringify(config.env[key]);
    importMetaKeys[`import.meta.env.${key}`] = val;
    importMetaEnvKeys[key] = val;
  }
  importMetaFallbackKeys["import.meta.env"] = `undefined`;
  const define = {
    ...processNodeEnv,
    ...importMetaKeys,
    ...userDefine,
    ...importMetaFallbackKeys
  };
  if ("import.meta.env" in define) {
    define["import.meta.env"] = serializeDefine({
      ...importMetaEnvKeys,
      ...userDefineEnv
    });
  }
  return define;
}
function serializeDefine(define) {
  let res = `{`;
  const keys = Object.keys(define);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const val = define[key];
    res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`;
    if (i !== keys.length - 1)
      res += `, `;
  }
  return `${res}}`;
}
function handleDefineValue(value) {
  if (typeof value === "undefined")
    return "undefined";
  if (typeof value === "string")
    return value;
  return JSON.stringify(value);
}
function canJsonParse(value) {
  try {
    JSON.parse(value);
    return true;
  } catch {
    return false;
  }
}

// src/core/resolvePluginOptions.ts
function resolvePluginOptions({
  prefix = [],
  wsPrefix = [],
  cwd,
  include = ["mock/**/*.mock.{js,ts,cjs,mjs,json,json5}"],
  exclude = ["**/node_modules/**", "**/.vscode/**", "**/.git/**"],
  reload = false,
  log = "info",
  cors: cors2 = true,
  formidableOptions = {},
  build: build2 = false,
  cookiesOptions = {},
  bodyParserOptions = {},
  priority = {}
}, config) {
  const logger = createLogger("vite:mock", isBoolean(log) ? log ? "info" : "error" : log);
  const { httpProxies } = ensureProxies(config.server.proxy || {});
  const proxies = uniq([...toArray3(prefix), ...httpProxies]);
  const wsProxies = toArray3(wsPrefix);
  if (!proxies.length && !wsProxies.length)
    logger.warn(`No proxy was configured, mock server will not work. See ${color.cyan("https://vite-plugin-mock-dev-server.netlify.app/guide/usage")}`);
  const enabled = cors2 === false ? false : config.server.cors !== false;
  let corsOptions = {};
  if (enabled && config.server.cors !== false) {
    corsOptions = {
      ...corsOptions,
      ...typeof config.server.cors === "boolean" ? {} : config.server.cors
    };
  }
  if (enabled && cors2 !== false) {
    corsOptions = {
      ...corsOptions,
      ...typeof cors2 === "boolean" ? {} : cors2
    };
  }
  const alias = [];
  const aliasConfig = config.resolve.alias || [];
  if (isArray(aliasConfig)) {
    alias.push(...aliasConfig);
  } else {
    Object.entries(aliasConfig).forEach(([find, replacement]) => {
      alias.push({ find, replacement });
    });
  }
  return {
    cwd: cwd || process5.cwd(),
    include,
    exclude,
    context: config.root,
    reload,
    cors: enabled ? corsOptions : false,
    cookiesOptions,
    log,
    formidableOptions: {
      multiples: true,
      ...formidableOptions
    },
    bodyParserOptions,
    priority,
    build: build2 ? Object.assign(
      {
        serverPort: 8080,
        dist: "mockServer",
        log: "error"
      },
      typeof build2 === "object" ? build2 : {}
    ) : false,
    proxies,
    wsProxies,
    logger,
    alias,
    define: viteDefine(config)
  };
}

// src/plugin.ts
function mockDevServerPlugin(options = {}) {
  const plugins = [serverPlugin(options)];
  if (options.build)
    plugins.push(buildPlugin(options));
  return plugins;
}
function buildPlugin(options) {
  let viteConfig = {};
  let resolvedOptions;
  return {
    name: "vite-plugin-mock-dev-server-generator",
    enforce: "post",
    apply: "build",
    configResolved(config) {
      viteConfig = config;
      resolvedOptions = resolvePluginOptions(options, config);
      config.logger.warn("");
    },
    async buildEnd(error) {
      if (error || viteConfig.command !== "build")
        return;
      await generateMockServer(this, resolvedOptions);
    }
  };
}
function serverPlugin(options) {
  let resolvedOptions;
  return {
    name: "vite-plugin-mock-dev-server",
    enforce: "pre",
    apply: "serve",
    config(config) {
      const wsPrefix = toArray4(options.wsPrefix);
      if (wsPrefix.length && config.server?.proxy) {
        const proxy = {};
        Object.keys(config.server.proxy).forEach((key) => {
          if (!wsPrefix.includes(key))
            proxy[key] = config.server.proxy[key];
        });
        config.server.proxy = proxy;
      }
      recoverRequest(config);
    },
    configResolved(config) {
      resolvedOptions = resolvePluginOptions(options, config);
      config.logger.warn("");
    },
    configureServer({ middlewares, httpServer, ws }) {
      const middlewareList = mockServerMiddleware(resolvedOptions, httpServer, ws);
      middlewareList.forEach((middleware) => middlewares.use(middleware));
    },
    configurePreviewServer({ middlewares, httpServer }) {
      const middlewareList = mockServerMiddleware(resolvedOptions, httpServer);
      middlewareList.forEach((middleware) => middlewares.use(middleware));
    }
  };
}

// src/index.ts
var src_default = mockDevServerPlugin;
export {
  baseMiddleware,
  createDefineMock,
  createLogger,
  src_default as default,
  defineMock,
  defineMockData,
  logLevels,
  mockDevServerPlugin,
  mockWebSocket,
  sortByValidator,
  transformMockData,
  transformRawData
};
