"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; } var _class;



var _chunkFND5XIG2cjs = require('./chunk-FND5XIG2.cjs');















var _chunkS76FMTCDcjs = require('./chunk-S76FMTCD.cjs');

// src/plugin.ts
var _utils = require('@pengzhanbo/utils');

// src/core/build.ts
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);
var _promises = require('fs/promises'); var _promises2 = _interopRequireDefault(_promises);
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _process = require('process'); var _process2 = _interopRequireDefault(_process);

var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
var _iscoremodule = require('is-core-module'); var _iscoremodule2 = _interopRequireDefault(_iscoremodule);
var _pluginutils = require('@rollup/pluginutils');
var _picocolors = require('picocolors'); var _picocolors2 = _interopRequireDefault(_picocolors);

// src/core/compiler.ts


var _url = require('url');

var _esbuild = require('esbuild');
var _json5 = require('json5'); var _json52 = _interopRequireDefault(_json5);
var externalizeDeps = {
  name: "externalize-deps",
  setup(build2) {
    build2.onResolve({ filter: /.*/ }, ({ path: id }) => {
      if (id[0] !== "." && !_path2.default.isAbsolute(id))
        return { external: true };
    });
  }
};
var json5Loader = {
  name: "json5-loader",
  setup(build2) {
    build2.onLoad({ filter: /\.json5$/ }, async ({ path: path3 }) => {
      const content = await _fs.promises.readFile(path3, "utf-8");
      return {
        contents: `export default ${JSON.stringify(_json52.default.parse(content))}`,
        loader: "js"
      };
    });
  }
};
var jsonLoader = {
  name: "json-loader",
  setup(build2) {
    build2.onLoad({ filter: /\.json$/ }, async ({ path: path3 }) => {
      const content = await _fs.promises.readFile(path3, "utf-8");
      return {
        contents: `export default ${content}`,
        loader: "js"
      };
    });
  }
};
var renamePlugin = {
  name: "rename-plugin",
  setup(build2) {
    build2.onResolve({ filter: /.*/ }, ({ path: id }) => {
      if (id === "vite-plugin-mock-dev-server") {
        return {
          path: "vite-plugin-mock-dev-server/helper",
          external: true
        };
      }
      return null;
    });
  }
};
function aliasPlugin(alias) {
  return {
    name: "alias-plugin",
    setup(build2) {
      build2.onResolve({ filter: /.*/ }, async ({ path: id }) => {
        const matchedEntry = alias.find(({ find: find2 }) => aliasMatches(find2, id));
        if (!matchedEntry)
          return null;
        const { find, replacement } = matchedEntry;
        const result = await build2.resolve(id.replace(find, replacement), {
          kind: "import-statement",
          resolveDir: replacement,
          namespace: "file"
        });
        return {
          path: result.path,
          external: false
        };
      });
    }
  };
}
function aliasMatches(pattern, importee) {
  if (pattern instanceof RegExp)
    return pattern.test(importee);
  if (importee.length < pattern.length)
    return false;
  if (importee === pattern)
    return true;
  return importee.startsWith(`${pattern}/`);
}
async function transformWithEsbuild(entryPoint, options) {
  const { isESM = true, define, alias, cwd = _process2.default.cwd() } = options;
  const filepath = _path2.default.resolve(cwd, entryPoint);
  const filename = _path2.default.basename(entryPoint);
  const dirname = _path2.default.dirname(filepath);
  try {
    const result = await _esbuild.build.call(void 0, {
      entryPoints: [entryPoint],
      outfile: "out.js",
      write: false,
      target: ["node18"],
      platform: "node",
      bundle: true,
      metafile: true,
      format: isESM ? "esm" : "cjs",
      define: {
        ...define,
        __dirname: JSON.stringify(dirname),
        __filename: JSON.stringify(filename),
        ...isESM ? {} : { "import.meta.url": JSON.stringify(_url.pathToFileURL.call(void 0, filepath)) }
      },
      plugins: [aliasPlugin(alias), renamePlugin, externalizeDeps, jsonLoader, json5Loader],
      absWorkingDir: cwd
    });
    return {
      code: result.outputFiles[0].text,
      deps: _optionalChain([result, 'access', _2 => _2.metafile, 'optionalAccess', _3 => _3.inputs]) || {}
    };
  } catch (e) {
    console.error(e);
  }
  return { code: "", deps: {} };
}
async function loadFromCode({
  filepath,
  code,
  isESM,
  cwd
}) {
  filepath = _path2.default.resolve(cwd, filepath);
  const ext = isESM ? ".mjs" : ".cjs";
  const filepathTmp = `${filepath}.timestamp-${Date.now()}${ext}`;
  const file = _url.pathToFileURL.call(void 0, filepathTmp).toString();
  await _fs.promises.writeFile(filepathTmp, code, "utf8");
  try {
    const mod = await import(file);
    return mod.default || mod;
  } finally {
    try {
      _fs2.default.unlinkSync(filepathTmp);
    } catch (e2) {
    }
  }
}

// src/core/build.ts
async function generateMockServer(ctx, options) {
  const include = _utils.toArray.call(void 0, options.include);
  const exclude = _utils.toArray.call(void 0, options.exclude);
  const cwd = options.cwd || _process2.default.cwd();
  let pkg = {};
  try {
    const pkgStr = _chunkS76FMTCDcjs.lookupFile.call(void 0, options.context, ["package.json"]);
    if (pkgStr)
      pkg = JSON.parse(pkgStr);
  } catch (e3) {
  }
  const outputDir = options.build.dist;
  const content = await generateMockEntryCode(cwd, include, exclude);
  const mockEntry = _path2.default.join(cwd, `mock-data-${Date.now()}.js`);
  await _promises2.default.writeFile(mockEntry, content, "utf-8");
  const { code, deps } = await transformWithEsbuild(mockEntry, options);
  const mockDeps = getMockDependencies(deps, options.alias);
  await _promises2.default.unlink(mockEntry);
  const outputList = [
    {
      filename: _path2.default.join(outputDir, "mock-data.js"),
      source: code
    },
    {
      filename: _path2.default.join(outputDir, "index.js"),
      source: generatorServerEntryCode(options)
    },
    {
      filename: _path2.default.join(outputDir, "package.json"),
      source: generatePackageJson(pkg, mockDeps)
    }
  ];
  try {
    if (_path2.default.isAbsolute(outputDir)) {
      for (const { filename } of outputList) {
        if (_fs2.default.existsSync(filename))
          await _promises2.default.rm(filename);
      }
      options.logger.info(`${_picocolors2.default.green("\u2713")} generate mock server in ${_picocolors2.default.cyan(outputDir)}`);
      for (const { filename, source } of outputList) {
        _fs2.default.mkdirSync(_path2.default.dirname(filename), { recursive: true });
        await _promises2.default.writeFile(filename, source, "utf-8");
        const sourceSize = (source.length / 1024).toFixed(2);
        const name = _path2.default.relative(outputDir, filename);
        const space = name.length < 30 ? " ".repeat(30 - name.length) : "";
        options.logger.info(`  ${_picocolors2.default.green(name)}${space}${_picocolors2.default.bold(_picocolors2.default.dim(`${sourceSize} kB`))}`);
      }
    } else {
      for (const { filename, source } of outputList) {
        ctx.emitFile({
          type: "asset",
          fileName: filename,
          source
        });
      }
    }
  } catch (e) {
    console.error(e);
  }
}
function getMockDependencies(deps, alias) {
  const list = /* @__PURE__ */ new Set();
  const excludeDeps = ["vite-plugin-mock-dev-server", "connect", "cors"];
  const isAlias = (p) => alias.find(({ find }) => aliasMatches(find, p));
  Object.keys(deps).forEach((mPath) => {
    const imports = deps[mPath].imports.filter((_) => _.external && !_.path.startsWith("<define:") && !isAlias(_.path)).map((_) => _.path);
    imports.forEach((dep) => {
      const name = normalizePackageName(dep);
      if (!excludeDeps.includes(name) && !_iscoremodule2.default.call(void 0, name))
        list.add(name);
    });
  });
  return Array.from(list);
}
function normalizePackageName(dep) {
  const [scope, name] = dep.split("/");
  if (scope[0] === "@") {
    return `${scope}/${name}`;
  }
  return scope;
}
function generatePackageJson(pkg, mockDeps) {
  const { dependencies = {}, devDependencies = {} } = pkg;
  const dependents = { ...dependencies, ...devDependencies };
  const mockPkg = {
    name: "mock-server",
    type: "module",
    scripts: {
      start: "node index.js"
    },
    dependencies: {
      connect: "^3.7.0",
      ["vite-plugin-mock-dev-server"]: `^${"1.7.0"}`,
      cors: "^2.8.5"
    },
    pnpm: { peerDependencyRules: { ignoreMissing: ["vite"] } }
  };
  mockDeps.forEach((dep) => {
    mockPkg.dependencies[dep] = dependents[dep] || "latest";
  });
  return JSON.stringify(mockPkg, null, 2);
}
function generatorServerEntryCode({
  proxies,
  wsProxies,
  cookiesOptions,
  bodyParserOptions,
  priority,
  build: build2
}) {
  const { serverPort, log } = build2;
  return `import { createServer } from 'node:http';
import connect from 'connect';
import corsMiddleware from 'cors';
import { baseMiddleware, createLogger, mockWebSocket } from 'vite-plugin-mock-dev-server/server';
import mockData from './mock-data.js';

const app = connect();
const server = createServer(app);
const logger = createLogger('mock-server', '${log}');
const proxies = ${JSON.stringify(proxies)};
const wsProxies = ${JSON.stringify(wsProxies)};
const cookiesOptions = ${JSON.stringify(cookiesOptions)};
const bodyParserOptions = ${JSON.stringify(bodyParserOptions)};
const priority = ${JSON.stringify(priority)};
const compiler = { mockData }

mockWebSocket(compiler, server, { wsProxies, cookiesOptions, logger });

app.use(corsMiddleware());
app.use(baseMiddleware(compiler, {
  formidableOptions: { multiples: true },
  proxies,
  priority,
  cookiesOptions,
  bodyParserOptions,
  logger,
}));

server.listen(${serverPort});

console.log('listen: http://localhost:${serverPort}');
`;
}
async function generateMockEntryCode(cwd, include, exclude) {
  const includePaths = await _fastglob2.default.call(void 0, include, { cwd });
  const includeFilter = _pluginutils.createFilter.call(void 0, include, exclude, {
    resolve: false
  });
  const mockFiles = includePaths.filter(includeFilter);
  let importers = "";
  const exporters = [];
  mockFiles.forEach((filepath, index) => {
    const file = _chunkS76FMTCDcjs.normalizePath.call(void 0, _path2.default.join(cwd, filepath));
    importers += `import * as m${index} from '${file}';
`;
    exporters.push(`[m${index}, '${filepath}']`);
  });
  return `import { transformMockData, transformRawData } from 'vite-plugin-mock-dev-server/server';
${importers}
const exporters = [
  ${exporters.join(",\n  ")}
];
const mockList = exporters.map(([mod, filepath]) => {
  const raw = mod.default || mod;
  return transformRawData(raw, filepath);
});
export default transformMockData(mockList);`;
}

// src/core/mockMiddleware.ts
var _cors = require('cors'); var _cors2 = _interopRequireDefault(_cors);
var _pathtoregexp = require('path-to-regexp');

// src/core/mockCompiler.ts
var _events = require('events'); var _events2 = _interopRequireDefault(_events);


var _chokidar = require('chokidar'); var _chokidar2 = _interopRequireDefault(_chokidar);


function createMockCompiler(options) {
  return new MockCompiler(options);
}
var MockCompiler = (_class = class extends _events2.default {
  constructor(options) {
    super();_class.prototype.__init.call(this);_class.prototype.__init2.call(this);_class.prototype.__init3.call(this);_class.prototype.__init4.call(this);;
    this.options = options;
    this.cwd = options.cwd || _process2.default.cwd();
    try {
      const pkg = _chunkS76FMTCDcjs.lookupFile.call(void 0, this.cwd, ["package.json"]);
      this.moduleType = !!pkg && JSON.parse(pkg).type === "module" ? "esm" : "cjs";
    } catch (e4) {
    }
  }
  __init() {this.moduleCache = /* @__PURE__ */ new Map()}
  __init2() {this.moduleDeps = /* @__PURE__ */ new Map()}
  
  
  
  __init3() {this.moduleType = "cjs"}
  __init4() {this._mockData = {}}
  get mockData() {
    return this._mockData;
  }
  run() {
    const { include, exclude } = this.options;
    const includeFilter = _pluginutils.createFilter.call(void 0, include, exclude, { resolve: false });
    _fastglob2.default.call(void 0, include, { cwd: this.cwd }).then(
      (files) => files.filter(includeFilter).map((file) => () => this.loadMock(file))
    ).then((loadList) => _utils.promiseParallel.call(void 0, loadList, 10)).then(() => this.updateMockList());
    this.watchMockEntry();
    this.watchDeps();
    let timer = null;
    this.on("mock:update", async (filepath) => {
      if (!includeFilter(filepath))
        return;
      await this.loadMock(filepath);
      if (timer)
        clearImmediate(timer);
      timer = setImmediate(() => {
        this.updateMockList();
        this.emit("mock:update-end", filepath);
        timer = null;
      });
    });
    this.on("mock:unlink", async (filepath) => {
      if (!includeFilter(filepath))
        return;
      this.moduleCache.delete(filepath);
      this.updateMockList();
      this.emit("mock:update-end", filepath);
    });
  }
  watchMockEntry() {
    const { include } = this.options;
    const [firstGlob, ...otherGlob] = _utils.toArray.call(void 0, include);
    const watcher = this.mockWatcher = _chokidar2.default.watch(firstGlob, {
      ignoreInitial: true,
      cwd: this.cwd
    });
    if (otherGlob.length > 0)
      otherGlob.forEach((glob) => watcher.add(glob));
    watcher.on("add", async (filepath) => {
      filepath = _chunkS76FMTCDcjs.normalizePath.call(void 0, filepath);
      this.emit("mock:update", filepath);
      _chunkS76FMTCDcjs.debug.call(void 0, "watcher:add", filepath);
    });
    watcher.on("change", async (filepath) => {
      filepath = _chunkS76FMTCDcjs.normalizePath.call(void 0, filepath);
      this.emit("mock:update", filepath);
      _chunkS76FMTCDcjs.debug.call(void 0, "watcher:change", filepath);
    });
    watcher.on("unlink", async (filepath) => {
      filepath = _chunkS76FMTCDcjs.normalizePath.call(void 0, filepath);
      this.emit("mock:unlink", filepath);
      _chunkS76FMTCDcjs.debug.call(void 0, "watcher:unlink", filepath);
    });
  }
  /**
   * 监听 mock文件依赖的本地文件变动，
   * mock依赖文件更新，mock文件也一并更新
   */
  watchDeps() {
    const oldDeps = [];
    this.depsWatcher = _chokidar2.default.watch([], {
      ignoreInitial: true,
      cwd: this.cwd
    });
    this.depsWatcher.on("change", (filepath) => {
      filepath = _chunkS76FMTCDcjs.normalizePath.call(void 0, filepath);
      const mockFiles = this.moduleDeps.get(filepath);
      _optionalChain([mockFiles, 'optionalAccess', _4 => _4.forEach, 'call', _5 => _5((file) => {
        this.emit("mock:update", file);
      })]);
    });
    this.depsWatcher.on("unlink", (filepath) => {
      filepath = _chunkS76FMTCDcjs.normalizePath.call(void 0, filepath);
      this.moduleDeps.delete(filepath);
    });
    this.on("update:deps", () => {
      const deps = [];
      for (const [dep] of this.moduleDeps.entries())
        deps.push(dep);
      const exactDeps = deps.filter((dep) => !oldDeps.includes(dep));
      if (exactDeps.length > 0)
        this.depsWatcher.add(exactDeps);
    });
  }
  close() {
    _optionalChain([this, 'access', _6 => _6.mockWatcher, 'optionalAccess', _7 => _7.close, 'call', _8 => _8()]);
    _optionalChain([this, 'access', _9 => _9.depsWatcher, 'optionalAccess', _10 => _10.close, 'call', _11 => _11()]);
  }
  updateMockList() {
    this._mockData = _chunkS76FMTCDcjs.transformMockData.call(void 0, this.moduleCache);
  }
  updateModuleDeps(filepath, deps) {
    Object.keys(deps).forEach((mPath) => {
      const imports = deps[mPath].imports.map((_) => _.path);
      imports.forEach((dep) => {
        if (!this.moduleDeps.has(dep))
          this.moduleDeps.set(dep, /* @__PURE__ */ new Set());
        const cur = this.moduleDeps.get(dep);
        cur.add(filepath);
      });
    });
    this.emit("update:deps");
  }
  async loadMock(filepath) {
    if (!filepath)
      return;
    let isESM = false;
    if (/\.m[jt]s$/.test(filepath))
      isESM = true;
    else if (/\.c[jt]s$/.test(filepath))
      isESM = false;
    else
      isESM = this.moduleType === "esm";
    const { define, alias } = this.options;
    const { code, deps } = await transformWithEsbuild(
      filepath,
      { isESM, define, alias, cwd: this.cwd }
    );
    try {
      const raw = await loadFromCode({ filepath, code, isESM, cwd: this.cwd }) || {};
      this.moduleCache.set(filepath, _chunkS76FMTCDcjs.transformRawData.call(void 0, raw, filepath));
      this.updateModuleDeps(filepath, deps);
    } catch (e) {
      console.error(e);
    }
  }
}, _class);

// src/core/mockMiddleware.ts
function mockServerMiddleware(options, server, ws) {
  const compiler = createMockCompiler(options);
  compiler.run();
  compiler.on("mock:update-end", () => {
    if (options.reload)
      _optionalChain([ws, 'optionalAccess', _12 => _12.send, 'call', _13 => _13({ type: "full-reload" })]);
  });
  _optionalChain([server, 'optionalAccess', _14 => _14.on, 'call', _15 => _15("close", () => compiler.close())]);
  _chunkS76FMTCDcjs.mockWebSocket.call(void 0, compiler, server, options);
  const middlewares = [];
  middlewares.push(
    /**
     * 在 vite 的开发服务中，由于插件 的 enforce 为 `pre`，
     * mock 中间件的执行顺序 早于 vite 内部的 cors 中间件执行,
     * 这导致了 vite 默认开启的 cors 对 mock 请求不生效。
     * 在一些比如 微前端项目、或者联合项目中，会由于端口不一致而导致跨域问题。
     * 所以在这里，使用 cors 中间件 来解决这个问题。
     *
     * 同时为了使 插件内的 cors 和 vite 的 cors 不产生冲突，并拥有一致的默认行为，
     * 也会使用 viteConfig.server.cors 配置，并支持 用户可以对 mock 中的 cors 中间件进行配置。
     * 而用户的配置也仅对 mock 的接口生效。
     */
    corsMiddleware(compiler, options),
    _chunkS76FMTCDcjs.baseMiddleware.call(void 0, compiler, options)
  );
  return middlewares.filter(Boolean);
}
function corsMiddleware(compiler, { proxies, cors: corsOptions }) {
  return !corsOptions ? void 0 : function(req, res, next) {
    const { pathname } = _chunkS76FMTCDcjs.urlParse.call(void 0, req.url);
    if (!pathname || proxies.length === 0 || !proxies.some((context) => _chunkS76FMTCDcjs.doesProxyContextMatchUrl.call(void 0, context, req.url))) {
      return next();
    }
    const mockData = compiler.mockData;
    const mockUrl = Object.keys(mockData).find(
      (key) => _pathtoregexp.pathToRegexp.call(void 0, key).test(pathname)
    );
    if (!mockUrl)
      return next();
    _cors2.default.call(void 0, corsOptions)(req, res, next);
  };
}

// src/core/resolvePluginOptions.ts




// src/core/define.ts

function viteDefine(config) {
  const processNodeEnv = {};
  const nodeEnv = _process2.default.env.NODE_ENV || config.mode;
  Object.assign(processNodeEnv, {
    "process.env.NODE_ENV": JSON.stringify(nodeEnv),
    "global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
    "globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
  });
  const userDefine = {};
  const userDefineEnv = {};
  for (const key in config.define) {
    const val = config.define[key];
    const isMetaEnv = key.startsWith("import.meta.env.");
    if (typeof val === "string") {
      if (canJsonParse(val)) {
        userDefine[key] = val;
        if (isMetaEnv)
          userDefineEnv[key.slice(16)] = val;
      }
    } else {
      userDefine[key] = handleDefineValue(val);
      if (isMetaEnv)
        userDefineEnv[key.slice(16)] = val;
    }
  }
  const importMetaKeys = {};
  const importMetaEnvKeys = {};
  const importMetaFallbackKeys = {};
  importMetaKeys["import.meta.hot"] = `undefined`;
  for (const key in config.env) {
    const val = JSON.stringify(config.env[key]);
    importMetaKeys[`import.meta.env.${key}`] = val;
    importMetaEnvKeys[key] = val;
  }
  importMetaFallbackKeys["import.meta.env"] = `undefined`;
  const define = {
    ...processNodeEnv,
    ...importMetaKeys,
    ...userDefine,
    ...importMetaFallbackKeys
  };
  if ("import.meta.env" in define) {
    define["import.meta.env"] = serializeDefine({
      ...importMetaEnvKeys,
      ...userDefineEnv
    });
  }
  return define;
}
function serializeDefine(define) {
  let res = `{`;
  const keys = Object.keys(define);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const val = define[key];
    res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`;
    if (i !== keys.length - 1)
      res += `, `;
  }
  return `${res}}`;
}
function handleDefineValue(value) {
  if (typeof value === "undefined")
    return "undefined";
  if (typeof value === "string")
    return value;
  return JSON.stringify(value);
}
function canJsonParse(value) {
  try {
    JSON.parse(value);
    return true;
  } catch (e5) {
    return false;
  }
}

// src/core/resolvePluginOptions.ts
function resolvePluginOptions({
  prefix = [],
  wsPrefix = [],
  cwd,
  include = ["mock/**/*.mock.{js,ts,cjs,mjs,json,json5}"],
  exclude = ["**/node_modules/**", "**/.vscode/**", "**/.git/**"],
  reload = false,
  log = "info",
  cors: cors2 = true,
  formidableOptions = {},
  build: build2 = false,
  cookiesOptions = {},
  bodyParserOptions = {},
  priority = {}
}, config) {
  const logger = _chunkS76FMTCDcjs.createLogger.call(void 0, "vite:mock", _utils.isBoolean.call(void 0, log) ? log ? "info" : "error" : log);
  const { httpProxies } = _chunkS76FMTCDcjs.ensureProxies.call(void 0, config.server.proxy || {});
  const proxies = _utils.uniq.call(void 0, [..._utils.toArray.call(void 0, prefix), ...httpProxies]);
  const wsProxies = _utils.toArray.call(void 0, wsPrefix);
  if (!proxies.length && !wsProxies.length)
    logger.warn(`No proxy was configured, mock server will not work. See ${_picocolors2.default.cyan("https://vite-plugin-mock-dev-server.netlify.app/guide/usage")}`);
  const enabled = cors2 === false ? false : config.server.cors !== false;
  let corsOptions = {};
  if (enabled && config.server.cors !== false) {
    corsOptions = {
      ...corsOptions,
      ...typeof config.server.cors === "boolean" ? {} : config.server.cors
    };
  }
  if (enabled && cors2 !== false) {
    corsOptions = {
      ...corsOptions,
      ...typeof cors2 === "boolean" ? {} : cors2
    };
  }
  const alias = [];
  const aliasConfig = config.resolve.alias || [];
  if (_utils.isArray.call(void 0, aliasConfig)) {
    alias.push(...aliasConfig);
  } else {
    Object.entries(aliasConfig).forEach(([find, replacement]) => {
      alias.push({ find, replacement });
    });
  }
  return {
    cwd: cwd || _process2.default.cwd(),
    include,
    exclude,
    context: config.root,
    reload,
    cors: enabled ? corsOptions : false,
    cookiesOptions,
    log,
    formidableOptions: {
      multiples: true,
      ...formidableOptions
    },
    bodyParserOptions,
    priority,
    build: build2 ? Object.assign(
      {
        serverPort: 8080,
        dist: "mockServer",
        log: "error"
      },
      typeof build2 === "object" ? build2 : {}
    ) : false,
    proxies,
    wsProxies,
    logger,
    alias,
    define: viteDefine(config)
  };
}

// src/plugin.ts
function mockDevServerPlugin(options = {}) {
  const plugins = [serverPlugin(options)];
  if (options.build)
    plugins.push(buildPlugin(options));
  return plugins;
}
function buildPlugin(options) {
  let viteConfig = {};
  let resolvedOptions;
  return {
    name: "vite-plugin-mock-dev-server-generator",
    enforce: "post",
    apply: "build",
    configResolved(config) {
      viteConfig = config;
      resolvedOptions = resolvePluginOptions(options, config);
      config.logger.warn("");
    },
    async buildEnd(error) {
      if (error || viteConfig.command !== "build")
        return;
      await generateMockServer(this, resolvedOptions);
    }
  };
}
function serverPlugin(options) {
  let resolvedOptions;
  return {
    name: "vite-plugin-mock-dev-server",
    enforce: "pre",
    apply: "serve",
    config(config) {
      const wsPrefix = _utils.toArray.call(void 0, options.wsPrefix);
      if (wsPrefix.length && _optionalChain([config, 'access', _16 => _16.server, 'optionalAccess', _17 => _17.proxy])) {
        const proxy = {};
        Object.keys(config.server.proxy).forEach((key) => {
          if (!wsPrefix.includes(key))
            proxy[key] = config.server.proxy[key];
        });
        config.server.proxy = proxy;
      }
      _chunkS76FMTCDcjs.recoverRequest.call(void 0, config);
    },
    configResolved(config) {
      resolvedOptions = resolvePluginOptions(options, config);
      config.logger.warn("");
    },
    configureServer({ middlewares, httpServer, ws }) {
      const middlewareList = mockServerMiddleware(resolvedOptions, httpServer, ws);
      middlewareList.forEach((middleware) => middlewares.use(middleware));
    },
    configurePreviewServer({ middlewares, httpServer }) {
      const middlewareList = mockServerMiddleware(resolvedOptions, httpServer);
      middlewareList.forEach((middleware) => middlewares.use(middleware));
    }
  };
}

// src/index.ts
var src_default = mockDevServerPlugin;













exports.baseMiddleware = _chunkS76FMTCDcjs.baseMiddleware; exports.createDefineMock = _chunkFND5XIG2cjs.createDefineMock; exports.createLogger = _chunkS76FMTCDcjs.createLogger; exports.default = src_default; exports.defineMock = _chunkFND5XIG2cjs.defineMock; exports.defineMockData = _chunkFND5XIG2cjs.defineMockData; exports.logLevels = _chunkS76FMTCDcjs.logLevels; exports.mockDevServerPlugin = mockDevServerPlugin; exports.mockWebSocket = _chunkS76FMTCDcjs.mockWebSocket; exports.sortByValidator = _chunkS76FMTCDcjs.sortByValidator; exports.transformMockData = _chunkS76FMTCDcjs.transformMockData; exports.transformRawData = _chunkS76FMTCDcjs.transformRawData;
