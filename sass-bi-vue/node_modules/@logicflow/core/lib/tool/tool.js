"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tool = void 0;
var TextEditTool_1 = __importDefault(require("./TextEditTool"));
var MultipleSelectTool_1 = __importDefault(require("./MultipleSelectTool"));
var constant_1 = require("../constant");
var Tool = /** @class */ (function () {
    function Tool(instance) {
        this.toolMap = new Map();
        this.instance = instance;
        if (!this.isDisabledTool(TextEditTool_1.default.toolName)) {
            this.registerTool(TextEditTool_1.default.toolName, TextEditTool_1.default);
        }
        if (!this.isDisabledTool(MultipleSelectTool_1.default.toolName)) {
            this.registerTool(MultipleSelectTool_1.default.toolName, MultipleSelectTool_1.default);
        }
        // @see https://github.com/didi/LogicFlow/issues/152
        var graphModel = instance.graphModel;
        var eventCenter = graphModel.eventCenter;
        eventCenter.on("".concat(constant_1.EventType.GRAPH_TRANSFORM, ",").concat(constant_1.EventType.NODE_CLICK, ",").concat(constant_1.EventType.BLANK_CLICK, " "), function () {
            var _a;
            var textEditElement = graphModel.textEditElement, _b = graphModel.editConfigModel, edgeTextEdit = _b.edgeTextEdit, nodeTextEdit = _b.nodeTextEdit;
            // fix #826, 保留之前的文本可以编辑点击空白才设置为不可编辑。如果以后有其他需求再改。
            if ((edgeTextEdit || nodeTextEdit) && textEditElement) {
                (_a = graphModel.textEditElement) === null || _a === void 0 ? void 0 : _a.setElementState(constant_1.ElementState.DEFAULT);
            }
        });
    }
    Tool.prototype.isDisabledTool = function (toolName) {
        var _a;
        return ((_a = this.instance.options.disabledTools) === null || _a === void 0 ? void 0 : _a.indexOf(toolName)) !== -1;
    };
    Tool.prototype.registerTool = function (name, component) {
        this.toolMap.set(name, component);
    };
    Tool.prototype.getTools = function () {
        return Array.from(this.toolMap.values());
    };
    Tool.prototype.getInstance = function () {
        return this.instance;
    };
    return Tool;
}());
exports.Tool = Tool;
exports.default = Tool;
//# sourceMappingURL=tool.js.map