import TextEdit from './TextEditTool';
import MultipleSelect from './MultipleSelectTool';
import { ElementState, EventType } from '../constant';
var Tool = /** @class */ (function () {
    function Tool(instance) {
        this.toolMap = new Map();
        this.instance = instance;
        if (!this.isDisabledTool(TextEdit.toolName)) {
            this.registerTool(TextEdit.toolName, TextEdit);
        }
        if (!this.isDisabledTool(MultipleSelect.toolName)) {
            this.registerTool(MultipleSelect.toolName, MultipleSelect);
        }
        // @see https://github.com/didi/LogicFlow/issues/152
        var graphModel = instance.graphModel;
        var eventCenter = graphModel.eventCenter;
        eventCenter.on("".concat(EventType.GRAPH_TRANSFORM, ",").concat(EventType.NODE_CLICK, ",").concat(EventType.BLANK_CLICK, " "), function () {
            var _a;
            var textEditElement = graphModel.textEditElement, _b = graphModel.editConfigModel, edgeTextEdit = _b.edgeTextEdit, nodeTextEdit = _b.nodeTextEdit;
            // fix #826, 保留之前的文本可以编辑点击空白才设置为不可编辑。如果以后有其他需求再改。
            if ((edgeTextEdit || nodeTextEdit) && textEditElement) {
                (_a = graphModel.textEditElement) === null || _a === void 0 ? void 0 : _a.setElementState(ElementState.DEFAULT);
            }
        });
    }
    Tool.prototype.isDisabledTool = function (toolName) {
        var _a;
        return ((_a = this.instance.options.disabledTools) === null || _a === void 0 ? void 0 : _a.indexOf(toolName)) !== -1;
    };
    Tool.prototype.registerTool = function (name, component) {
        this.toolMap.set(name, component);
    };
    Tool.prototype.getTools = function () {
        return Array.from(this.toolMap.values());
    };
    Tool.prototype.getInstance = function () {
        return this.instance;
    };
    return Tool;
}());
export { Tool };
export default Tool;
//# sourceMappingURL=tool.js.map